var ex_dummy = class extends ExtensionCommon.ExtensionAPI {
  onStartup() {
    // To get access to registered implementations in parent code, use
    // ImplementationManager and register a listener:
    const { ImplementationManager } = ChromeUtils.import(
        this.extension.rootURI.resolve(
          "experiments/implementationprovider/ImplementationManager.jsm"));

    const implementationListener = {
      onRegisterImplementation: function(name, asyncConstructor) {
        // You might want to use the experiment with multiple types of
        // implementations, so haveing some naming convention seems useful:
        if (!name.startsWith('Aggregator:')) {
          return;
        }
        // You can then create instances of your WebExtension class (which live
        // in the WebExtension world, within the context that registered the
        // implementation!) using the async constructor-like function, and
        // interact with the result as if it the instance would live here:
        (async function(){
          console.log("EXPERIMENT: creating aggregator", name);
          const aggregatorInstance = await asyncConstructor(42);
          // no await necessary: addListener/removeListener are special methods
          // generated by the API of this proof-of-concept:
          aggregatorInstance.addListener({
            onTotalChange(newTotal) {
              console.log("EXPERIMENT: aggregator", name,
                  "changed its total to", newTotal);
            }
          })
          await aggregatorInstance.append(2);
          console.log("EXPERIMENT: 42 and 2 in", name, "result in a total of",
              await aggregatorInstance.getTotal());

          const aggregatorInstance2 = await asyncConstructor(1);
          await aggregatorInstance2.append(2);
          await aggregatorInstance2.append(3);
          console.log("EXPERIMENT: 1, 2 and 3 in", name, "result in a total of",
              await aggregatorInstance2.getTotal(),
              "(second instance w/o listeners)");
          aggregatorInstance2.close();

          await aggregatorInstance.append(2);
          console.log("EXPERIMENT: Appending 2 to the first", name,
              "resulted in", await aggregatorInstance.getTotal());

          aggregatorInstance.close();
        })().catch(console.error)
        // From the example, you might see the obvious limitations: interaction
        // is mostly limited to async functions with arguments and return values
        // that are supported by structured clone.
        //
        // That is primarily a limitation of the proof-of-concept: I tried to
        // keep things useful, but generic and simple at the same time. As an
        // example of how more advanced features can be realized, this API does
        // permit the WebExtension class to offer listener registration in
        // parent code â€“ the functions used for that are defined in the API
        // itself and use separate message passing to work efficiently.
        //
        // So we do have options to implement more complex things in actual
        // core APIs if the need arises, but I feel like this proof-of-concept
        // contains everything needed to be useful.
      },
      onUnregisterImplementation: function(name) {
        // As we did not register anything based on our Aggregators, we don't
        // have to unregister anything. In the real world, you would want to
        // unregister things once the implementation is no longer available or
        // changes. DO NOT SKIP THIS STEP.
        console.log("EXPERIMENT: Implementation for " + name
            + " unregistered.");
      }
    };

    ImplementationManager.addListener(implementationListener);
    // As ImplementationManager lives in the same add-on, so listener
    // unregistration is not strictly necessary. But just for cleanliness:
    this.onShutdown = (isAppShutdown) => {
      ImplementationManager.removeListener(implementationListener)
    };
  }
  getAPI(context) {
    return {ex_dummy: {}};
  }
};
